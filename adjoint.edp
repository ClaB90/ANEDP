/****************** Politecnico di Milano - ANEDP project ******************/
/* 														 					*
 *  	authors Edoardo Arbib 							 					*
 *				Claudia Bonomi 							 					*
 *											   			 					*
 *  	Descrizione: Per il problema aggiuto definiamo  					*
 *						- spazi funzionali		         					*
 *						- problema spaziale				 					*
 *					    - funzione per la soluzione del problema temporale  *
 * 														 					*
 ****************************************************************************/

// funzione p all'istante finale
func pT = 0.;

// funzione p sul bordo di dirichlet
func pb = 0.;

//definisco la funzione h = wstate - wd;
Yh h, hnext;

/****** 01.SPAZI FUNZIONALI ******/

fespace Ph( Th, P1 );
Ph p, pnext, ptest;

/****** 02.PROBLEMA SPAZIALE ******/ 
  
problem adjoint( p, ptest) = - int2d(Th)( pnext*ptest/dt )
							 + int2d(Th)( p*ptest/dt )			
						     + int2d(Th)( 0.5*( dx(p)*dx(ptest) + dy(p)*dy(ptest) ) ) 
						     + int2d(Th)( 0.5*( dx(pnext)*dx(ptest) + dy(pnext)*dy(ptest) ) ) 
						     - int2d(Th)( 0.5*( h*ptest ) ) 
						     - int2d(Th)( 0.5*( hnext*ptest ) ) 
						     + on(1,2,3,4, p=pb);

/* NB - u non cambia al passo temporale della p quello che cambia è la f, se dipende dal tempo, 
 *   	 quindi bisogna tener traccia della fnext;
 */

/****** 03.FUNZIONE PER SOLUZIONE IN TEMPO ******/ 

func real adjointt()
{
	cout << "Adjoint " << endl;
	
	//inizializzo le variabili iniziali ogni volta che chiamo la funzione
	//NB generalizza x dt
	int j = nsol;
	
	//cout << j << endl;
	
	Bpk[j-1] = pT;
	pnext=pT;
	t=T;
	h = sol[j-1] - wd;
	
	j--;

	//Devi risolvere un passo in meno per l'aggiunta poichè beta_0 == 0
	while( j > 0 )
	{
		//cout << "siamo al tempo   = " << t << endl;
		
		hnext = h;
		h = sol[j] - wd;
		
		adjoint;
		//plot( p, nbiso=40, value = 1, fill=1, wait = 0, cmm="p" );
		pnext=p;
		
		//cout << " j " << j << endl;
		Bpk[j-1]= (-1./alpha)*int2d(Th)( p * g );
		
		
		t -= dt;
		j--;
	}
	
	return 0;
}
