/****************** Politecnico di Milano - ANEDP project ******************/
/* 														 					*
 *  	authors Edoardo Arbib 							 					*
 *				Claudia Bonomi 							 					*
 *											   			 					*
 *  	Descrizione:   					   			 				        *
 *					   					   			 				        *
 *					   					   			 				        *
 *					    					   			 				    *
 * 														 					*
 ****************************************************************************/

verbosity=0;

/****** 00.PARAMETRI ******/

real N=80;

real T=0.1;
real t=0.01;

/* NB: fissato un numero di soluzioni il numero di intervalli sarà nsol-1 poichè la soluzione 
 *     è nota per i valori nodali.
 */
real nsol = 10;
real dt=T/(nsol-1);

/* nel file soluzioniEsatte.edp sono contenute le definizioni delle soluzioni esatte per w,p,u
 */
include "solEs.edp";

//Per il problema di controllo
real alpha, a, b, toll=0.,epsilon;
int k, Nmax;

func f = 0.;
func g = sin(pi*x)*sin(pi*y);
func  real PUab(real& x, real& y, real& z)
{
	real tmp=0.;
	
	tmp = max( x, min( z, y ) );
		
	return tmp;
}

/****** 01.MESH ******/
mesh Th = square( N, N, flags=1 );

/****** 02.SPAZI FUNZIONALI ******/
fespace Xh( Th, P0 );

Xh err, dJ;
real[int] u(nsol);

real a1 = -sqrt(5.);
func wa = exp(a1*pi^2*t)*sin(x*pi)*sin(y*pi);
func waT = exp(a1*pi^2*T)*sin(x*pi)*sin(y*pi);
func wd = (a1^2 - 5.)*pi^2*wa/(a1+2.) + 2.*pi^2*waT;

/****** 03.MATRICI E VETTORI ******/

/****** 04.SOLVE ******/   
//Vado a salvare il pezzetto B'pk per ogni passo temporale
real[int] Bpk(nsol), Bpkold(nsol);

// State problem 
include "state.edp";

// Adjoint Problem
include "adjoint.edp";


//Solution at 1st step
u = -25.;             //control
a = - 25.;
b = -1.;
alpha = pi^(-4.);     //acceleration parameter
epsilon = 1e-5;    //tolerance for the stopping criterion
Nmax = 300;        //max iterations number
k = 0;             //couter for iterative algorithm

statet(); 
//plot( w, nbiso = 40, fill=1, value = 1, wait = 0, cmm="initial y" );
//Initial value of the cost functional

adjointt();
//plot( p, nbiso = 40, fill=1, value = 1, wait = 1, cmm="initial p");

Bpkold = Bpk;

toll = 1;


//Iterative algorithm
while ( toll > epsilon  && k <= Nmax){
      
      k = k + 1;
      
      //Control Update
	  for(int i=0; i<nsol; i++)
	  {
		  u[i] = PUab(a,b,Bpk[i]);
		  //cout << "u[ " << i << "  ]" << u[i] << endl;
	  }
	  
      //u[] = tmp;  

      statet();  

      adjointt();
      
      cout << "k = " << k << endl;
	  
	  
	  for( int i = 0; i < nsol-1; i++)
	  {
		  if( i == 0 )
		  {
		  	toll = abs(Bpk[i]-Bpkold[i]);
		  }
		  else
		  {
		  	toll = max( toll, abs(Bpk[i]-Bpkold[i]));
		  }
		  
		  cout << " i = " << i << endl;
		  cout << "Bpk[i] = " << Bpk[i] << "  Bpkold[i] = " <<  Bpkold[i] << endl;
		  cout << "toll = " << toll << endl;
	  }

	  cout << "toll final = " << toll << endl;
	  
	  Bpkold = Bpk;

    };

cout << "==========================" << endl;
cout << "Number of  iterations = " << k << endl;



/****** 05.VISUALIZATION ******/ 
// Difference between the final state and the desired observation 
err = abs( w - wd );  
//plot( wdsol, nbiso = 40, fill=1, value = 1, wait = 1, cmm="w_d" );    
plot( err, nbiso = 40, fill=1, value = 1, wait = 1, cmm="|w-w_d|" );
plot( w, nbiso = 40, fill=1, value = 1, wait = 1, cmm="final w" );
plot( p, nbiso = 40, fill=1, value = 1, wait = 1, cmm="final p" );
