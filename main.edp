/****************** Politecnico di Milano - ANEDP project ******************/
/* 														 					*
 *  	authors Edoardo Arbib 							 					*
 *				Claudia Bonomi 							 					*
 *											   			 					*
 *  	Descrizione:   					   			 				        *
 *					   					   			 				        *
 *					   					   			 				        *
 *					    					   			 				    *
 * 														 					*
 ****************************************************************************/

verbosity=0;

/****** 00.PARAMETRI ******/

real N=80;

real T=1.;
real t=0.01;

real nsol = 10;
real dt=T/nsol;


include "solEs.edp";

//Per il problema di controllo
real lambda, dJ0norm, J, J0, dJtol, epsilon, alpha;
int k, Nmax;

func f = 0.;
lambda = 0.001;

/****** 01.MESH ******/
mesh Th = square( N, N, flags=1 );

/****** 02.SPAZI FUNZIONALI ******/
fespace Xh( Th, P0 );

Xh u, wd, err, dJ;
wd = 100.0 * x * y * ( 1 - x ) * ( 1 - y );

/****** 03.MATRICI E VETTORI ******/

/****** 04.SOLVE ******/   

// State problem 
include "state.edp";

// Adjoint Problem
include "adjoint.edp";


//Solution at 1st step
u = 0.;             //control
alpha = 200.0;     //acceleration parameter
epsilon = 1e-3;    //tolerance for the stopping criterion
Nmax = 300;        //max iterations number
k = 0;             //couter for iterative algorithm

statet(); 
plot( w, nbiso = 40, fill=1, value = 1, wait = 0, cmm="initial y" );
//Initial value of the cost functional
J0 = int2d( Th )(0.5*( w - wd )^2) + lambda *0.5* int2d( Th )( u^2 ); 
cout << "J0 = " << J0 << endl;

adjointt();
plot( p, nbiso = 40, fill=1, value = 1, wait = 0, cmm="initial p");

dJ = p + lambda * u;                     // J'(u0) = grad f(u0)
dJ0norm = sqrt( int2d( Th )( dJ^2 ) );   // || J'(u0) ||_{L^2(Omega)}
dJtol = 1.0;                             // to enter in the while loop

plot( w, nbiso = 40, value = true, wait = 0, cmm="initial w" );
plot( p, nbiso = 40, value = true, wait = 0, cmm="initial p");

//Iterative algorithm
while ( dJtol > epsilon  && k <= Nmax){
      
      k = k + 1;
      
      //Control Update
      u = u - alpha * dJ;  

      statet();  
     
      J = int2d( Th ) ( 0.5*( w - wd )^2 ) + lambda * 0.5 * int2d( Th ) ( u^2 );     

      adjointt();
      dJ = p + lambda * u;
      dJtol = sqrt( int2d( Th )( dJ^2 ) ) / dJ0norm;  // Monitored quantitw for the Stopping criterion
      
      cout << "k = " << k << endl;
      cout << "realtive error for J' = " << dJtol << endl;

    };

cout << "==========================" << endl;
cout << "J0 = " << J0 << endl;
cout << "J  = " << J << endl;
cout << "Number of  iterations = " << k << endl;



/****** 05.VISUALIZATION ******/ 
// Difference between the final state and the desired observation 
err = abs( w - wd );       
plot( err, nbiso = 40, fill=1, value = 1, wait = 1, cmm="|w-w_d|" );
plot( w, nbiso = 40, fill=1, value = 1, wait = 1, cmm="final w" );
plot( u, nbiso = 40, fill=1, value = 1, wait = 1, cmm="final u" );
