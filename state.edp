/*********************** Politecnico di Milano - ANEDP project ************************/
/* 														 					          *
 *  	authors Edoardo Arbib 							 					          *
 *				Claudia Bonomi 							 					          *
 *											   			 					          *
 *  	Descrizione: Per il problema di stato definiamo  					          *
 *						- spazi funzionali		         					          *
 *						- problema spaziale				 					          *
 *					    - funzione per la soluzione del problema temporale            * 
 *    					- norme dell'errore e analisi di convergenza                  *
 * 														 				 	 	 	  *
 * 		Dipendenze: main -> nsol + paramtri temporali + u(=soluzione controllo)  	  * 
 *						 -> alpha parametro del problema di controllo 				  *
 * 					soluzioniEsatte -> soluzione esatta di y e parametri t1 e t2 	  * 
 * 									   necessarie per il calcolo dell'errore     	  *
 * 					funzioni -> wa ed a1								 			  *
 * 														 				 	 	 	  *
 **************************************************************************************/

	
/****************** 00.PARAMETRI E FUNZIONI ******************/
// w0 soluzione all'istante iniziale
t=0.;
func w0 = -1.*(pi^2*wa)/(2+a1);

// wb funzione al bordo di dirchlet 
func wb = 0.;

/*la forzante del problema ha la seguente forma
 *	g0(t,x,y) = -pi^(4)*wa - PUad(-(exp(a1*pi^2*t)+exp(a1*pi^2*T))/(4.*alpha))
 * per calcolare il secondo termine è necessario usare le variabili di ausilio g0part e g0II
 * poichè freefem non ci permette di aglomerare le funzioni in un unica riga faremo dunque:
 * 		g0part= g0exp;
 *		g0II = PUabScal(g0part);
 */
func g0I = -pi^(4)*wa;
func g0exp = -(exp(a1*pi^2*t)+exp(a1*pi^2*T))/(4.*alpha);
real g0part, g0II;

func g0 = g0I - g0II;

/* Parametri per il calcolo dell'errore dello stato
 * errStateL2 = || pi*y -y_k ||L2
 *
 * errProjectStateL2 = || y -pi*y_k ||L2
 */
real errStateL2=0.;
real errProjectStateL2 = 0.; 

/****************** 01.SPAZI FUNZIONALI ******************/

fespace Yh( Th, P2 );

/* w soluzione del problema di stato al passo temporale corrente
 * wold suluzione del problema di stato al passo temporale precedente
 * wtest funzione test
 * g0old forzante al passo temporale precedente
 */
Yh w, wold, wtest, g0old;

//vettore della soluzioni w ad ogni passo temporale
Yh[int] sol(nsol);

/******************  02.PROBLEMA SPAZIALE ******************/
 
/* Lo schema di integrazione temporale implementato è una variante di Crank-Nicolson
 * in particolare viene effettuato:
 *  un passo di EI con passo temporale dimezzato
 *  nsol-2 passi di CN
 *  un passo di EA
 * Per questo motivo la matrice S rimane invariata dal primo al penultimo passo
 *  il parametro gamma verà settato a zero prima che la matrice S venga ricacolata 
 *  nel ultimo passo.
 */
real gamma=0.5;

/* uold e ui contengono il valore della soluzione di controllo al tempo t e t-dt
 * Al passo di EI solo la componente u(0) deve essere considerata
 * Per ogni passo i di CN le componenti u(i) ed u(i-1) devono essere considerati
 * Al passo di EA solo la componente u(nsol-1) deve essere considerata
 */
real uold=0., ui;

varf s(w,wtest) =   int2d(Th)( w*wtest/dt )
	        	  + int2d(Th)( gamma*( dx(w)*dx(wtest) + dy(w)*dy(wtest) ) )
				  + on(1,2,3,4, w=wb);

varf c(w,wtest) =   int2d(Th)( wold*wtest/dt )
				  - int2d(Th)( 0.5*( dx(wold)*dx(wtest) + dy(wold)*dy(wtest) )*(t>dt) )
				  + int2d(Th)( 0.5*( (uold + g0old)*wtest )*(t>dt) ) 
				  + int2d(Th)( gamma*( (ui + g0)*wtest ) );
					  
matrix S; 
real[int] bc(Yh.ndof);

S=s(Yh,Yh,solver=UMFPACK);
bc=s(0,Yh);


/****** 03.FUNZIONE PER SOLUZIONE IN TEMPO ******/ 

func real statet()
{
	cout << "State " << endl;
	
	real[int] tmp(Yh.ndof);
	real errL2=0.,normL2=0.;
	
	//inizializzo le variabili iniziali ogni volta che chiamo la funzione
	wold=w0;
	t=dt;

	for( int i=0; i<nsol-1; i++ )
	{
		//setto le variabili ui ed uold asicurandomi di non andare ad accedere la posizione u[-1]
		if( i > 0 )
		{
			uold= u[i-1];
		}
		
		ui=u[i];
		
		//aggiorno g0II
		g0part= g0exp;
		g0II = PUabScal(g0part);
		
		tmp = c(0,Yh);
		tmp += bc;
		
		//Risolvo
		w[] = S^-1*tmp;
		
	    //plot( w, value = 1, fill=1, wait = 0, cmm="w" );
		//cout << "siamo al tempo   = " << t << endl;
		
		//Calcolo dell'errore
		normL2 = int2d(Th)( (w-we)^2 );
		errL2 += dt*normL2;
		
		// salvo la mia soluzione al passo precedente
		sol[i]=w;
		
		//aggiorno wold, il tempo e g0old
		wold=w;
		t += dt;
		g0old = g0;
		
	}
	
	// passo di EA
	gamma=0.;
	
	S=s(Yh,Yh);
	
	tmp = c(0,Yh);
	tmp += bc;
	
	w[] = S^-1*tmp;
	
	sol[nsol-1]=w;
	
	//cout << "siamo al tempo = " << t << endl;
	//plot( w, value = 1, fill=1, wait = 0, cmm="w final" );
	
	//Calcolo dell'errore
	normL2 = int2d(Th)( (w-we)^2 );
	errL2 += dt*normL2;
	errStateL2 = sqrt(errL2);
	
	cout << "errore state L2  " << errStateL2 << endl;
	
	errL2 = 0.;
	
	errL2 = (   int2d(Th)( ( 1.5*sol[0] - 0.5*sol[1] - 1.5*we2 + 0.5*we1 )^2 )
		      + int2d(Th)( ( (sol[0]-we2)^2 ) )
			  + (1./4.)*int2d(Th)( ( 5*sol[0]-sol[1]-5*we2 +we1 )^2 )
			    )*(dt/12.);
	
	for( int i=1; i< nsol-3; i++)
	{
		errL2 += (   int2d(Th)( ( (sol[i-1]-we2)^2 ) )
					+ int2d(Th)( ( (sol[i]-we1)^2 ) )
					+ int2d(Th)( ( sol[i]+sol[i-1]-we2 -we1 )^2 ) 
					  )*(dt/6.);
		t1 += dt;
		t2 += dt;
	}
	
	errL2 += (   int2d(Th)( ( 1.5*sol[nsol-2] - 0.5*sol[nsol-3] - 1.5*we1 + 0.5*we2 )^2 )
			   + int2d(Th)( ( (sol[nsol-2]-we1)^2 ) )
			   + (1./4.)*int2d(Th)( ( 5*sol[nsol-2]-sol[nsol-3]-5*we1 +we2 )^2 )
				 )*(dt/12.);
	
	errProjectStateL2 = sqrt(errL2);
	
	cout << "errore project state L2  " << errProjectStateL2 << endl;
	
	return 0;
}



















