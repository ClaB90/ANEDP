/****************** Politecnico di Milano - ANEDP project ******************/
/* 														 					*
 *  	authors Edoardo Arbib 							 					*
 *				Claudia Bonomi 							 					*
 *											   			 					*
 *  	Descrizione:   					   			 				        *
 *					   					   			 				        *
 *					   					   			 				        *
 *					    					   			 				    *
 * 														 					*
 ****************************************************************************/

verbosity=0;

/****** 00.PARAMETRI ******/

/* Parametri temporali */
real T=0.5;
real t=0.;

/* NB: fissato un numero di soluzioni il numero di intervalli sarà nsol-1 poichè la soluzione è nota per i valori nodali. */
real nsol = 10;
real dt=T/(nsol-1);

/* Parametri Per il problema di controllo:
 *	alpha = acceleration parameter
 *	toll = variabile per la tolleranza
 *	epsilon = valore limite per la tolleranza
 *  k = numero di iterazione del ciclo di controllo
 *  Nmax = numero massimo di iterazioni
 *  u[] = vettore soluzione di controllo
 */
real alpha, toll=0.,epsilon;
int k, Nmax;
alpha = 1.;    
epsilon = 1e-5;    
Nmax = 300;        
k = 0;  

real[int] u(nsol); 

/* nel file funzioni.edp sono contenute le funzioni che caratterizzano l'operatore B ed yd
 */
include "funzioni.edp";

/* nel file UabSet.edp vengono definiti i limiti dell'insieme Uab e le funzioni di proiezione di 
 * uno scalare o di un vettore sullo spazio Uab
 */
include "UabSet.edp";   

/* nel file soluzioniEsatte.edp sono contenute le funzioni per soluzioni esatte per w,p,u
 */
include "soluzioniEsatte.edp";       

/* nel file mesh.edp è contenuta la mesh
 */
include "mesh.edp"; 

//Vado a salvare il pezzetto B'pk per ogni passo temporale
real[int] Bpk(nsol), Bpkold(nsol);

/* nel file state.edp sono contenuti i parametri e le funzioni necessari per il problema di stato 
 */
include "state.edp";

/* nel file adjoint.edp sono contenuti i parametri e le funzioni necessari per il problema aggiunto 
 */
include "adjoint.edp";

/* nel file funzioniErrore.edp le funzioni necessarie per il calcolo dell'errore del problema di stato
 * e di quello di controllo 
 */
//include "funzioniErrore.edp";

//Primo passo soluzione
//La variabile di controllo al primo passo viene settatta uguale al limite inferiore di Uab
u = a;          

statet(); 
//plot( w, nbiso = 40, fill=1, value = 1, wait = 0, cmm="initial y" );

adjointt();
//plot( p, nbiso = 40, fill=1, value = 1, wait = 1, cmm="initial p");

Bpkold = Bpk;

toll = 1;

//Iterative algorithm
while ( toll > epsilon  && k <= Nmax)
{      
      k = k + 1;
      
      //Control Update
	  u = PUab(Bpk);

      statet();  

      adjointt();
      
      cout << "k = " << k << endl;
	  
	  
	  for( int i = 0; i < nsol-1; i++)
	  {
		  if( i == 0 )
		  {
		  	toll = abs(Bpk[i]-Bpkold[i]);
		  }
		  else
		  {
		  	toll = max( toll, abs(Bpk[i]-Bpkold[i]));
		  }
		  
		  //cout << " i = " << i << endl;
		  //cout << "Bpk[i] = " << Bpk[i] << "  Bpkold[i] = " <<  Bpkold[i] << endl;
		  //cout << "toll = " << toll << endl;
	  }

	  cout << "toll final = " << toll << endl;
	  
	  Bpkold = Bpk;

    };

cout << "==========================" << endl;
cout << "Number of  iterations = " << k << endl;

real errProjectControlL2 = 0.; 

errProjectControlL2 = controltrap(u);
cout << "Errore errProjectControlL2 = " << errProjectControlL2 << endl;
cout << "Errore errProjectStateL2 = " << errProjectStateL2 << endl;


/****** 05.VISUALIZATION ******/ 
// Difference between the final state and the desired observation 
//err = abs( w - wd );  
//plot( err, nbiso = 40, fill=1, value = 1, wait = 1, cmm="|w-w_d|" );
plot( w, nbiso = 40, fill=1, value = 1, wait = 1, cmm="final w" );
plot( p, nbiso = 40, fill=1, value = 1, wait = 1, cmm="final p" );
