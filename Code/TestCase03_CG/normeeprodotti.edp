/****************** Politecnico di Milano - ANEDP project ******************/
/* 														 					*
 *  	authors Edoardo Arbib 							 					*
 *				Claudia Bonomi 							 					*
 *											   			 					*
 *  	Descrizione: definiamo le funzioni					 				*
 *						- normL2								      		*
 *						- < vect1, vect2>L2						      		*
 *																			*
 * 		Dipendenze:	main -> variabili t e T definite  						*
 * 														 					*
 ****************************************************************************/

/* norma L2 che utilizza il metodo dei trapezi sullo spazio Yh
 */
func real normL2Yh(real[int,int]& xx)
{
	real tmp=0;
	
	Yh x1,x2;
	
	for(int i=0; i< nsol-1; i++)
	{
		x1[] = xx(i,:);
		x2[] = xx(i+1,:);
		
		tmp += ( int2d(Th)(x1^2) 
			     + int2d(Th)(x2^2))*(dt/2.); 
	}
	
	tmp = sqrt(tmp);
	
	return tmp;
}

/* norma L2 che utilizza il metodo di Cavalieri Simpson sullo spazio Yh
*/
func real normL2YhCS(real[int,int] &xx)
{
	real tmp=0.;
	Yh x1,x2,x3;
	t=0;
	for(int i=0; i<nsol-1; ++i)
	{
		x1[]=xx(i,:);
		x2[]=xx(i+1,:);
		x3=(x1+x2)/2.;
		tmp += (dt/6.)*(int2d(Th)((x1-wd)^2)+int2d(Th)((x2-wdpp)^2)+4*int2d(Th)((x3-wdp)^2));
		t=t+dt;
	}
	tmp=sqrt(tmp);
	return tmp;
}

/* norma L2 che utilizza il metodo dei trapezi sullo spazio Ph
 */
func real normL2Ph(real[int,int]& xx)
{
	real tmp=0;
	
	Ph x1,x2;
	
	for(int i=0; i< nsol-1; i++)
	{
		x1[] = xx(i,:);
		x2[] = xx(i+1,:);
		
		tmp += ( int2d(Th)(x1^2) 
			     + int2d(Th)(x2^2))*(dt/2.); 
	}
	
	tmp = sqrt(tmp);
	
	return tmp;
}

/* La funzione prodottoL2 ricava il prodotto vettoriale temporale tra due vettori di soluzioni
 * dello stesso spazio funzionale 
 */
func real prodottoL2(real[int,int]& xx, real[int,int]& ww)
{
	real tmp=0;
	
	Yh x1,x2,x3,x4;
	
	for(int i=0; i< nsol-1; i++)
	{
		x1[] = xx(i,:);
		x2[] = ww(i,:);
		x3[] = xx(i+1,:);
		x4[] = ww(i+1,:);
		
		tmp += ( int2d(Th)(x1*x2) 
			     + int2d(Th)(x3*x4))*(dt/2.); 
	}
	
	return tmp;
}

func real prodottoL2CS(real[int,int] &xx, real[int,int] &ww)
{
	real tmp=0.;
	Yh x1,x2,x3,x4,x5,x6;
	t=0;
	for(int i=0; i<nsol-1; ++i)
	{
		x1[] = xx(i,:);
		x2[] = ww(i,:);
		x3[] = xx(i+1,:);
		x4[] = ww(i+1,:);
		x5=(x1+x3)/2.;
		x6=(x2+x4)/2.;
		tmp+= (dt/6.)*(int2d(Th)(x1*(wd-x2))+int2d(Th)(x3*(wdpp-x4))+4*int2d(Th)(x5*(wdp-x6)));
		t=t+dt;
	}
	return tmp;
}


/* norma L2 che utilizza il metodo dei trapezi per la soluzione di controllo
 * la proiezione sullo spazio di controllo avviene durante il calcolo della norma
 */
func real normL2u(real[int] &xx)
{
	real tmp=0;
	
	real x1,x2;
	
	for(int i=0; i< nsol-1; i++)
	{
		x1 = xx[i];
		x2 = xx[i+1];
		
		tmp += ( int2d(Th)((PUabScal(x1))^2) 
			     + int2d(Th)((PUabScal(x2))^2))*(dt/2.); 
	}
	
	tmp = sqrt(tmp);
	
	return tmp;
}
