/****************** Politecnico di Milano - ANEDP project ******************/
/* 														 					*
 *  	authors Edoardo Arbib 							 					*
 *				Claudia Bonomi 							 					*
 *											   			 					*
 *  	Descrizione: definizioni delle funzioni per errore	  				*
 *																			*
 * 		Dipendenze:	funzioni.edp -> waT e a1						        *		
 *				    soluzioniEsatte -> definizioni funzioni esatte			*
 * 					main -> nsol						 					*
 * 					state -> statesol[]					 					*
 * 														 					*
 ****************************************************************************/

/* Per il calcolo dell'errore di || pi*y -y_k ||L2 viene sommata ad ogni passo temporale la norma L2
 * la funzione seguente verr√† chiamata ad ogni passo temporale sommandone il risultato,
 */
func real normL2statet()
{
	real tmp=0.;
	
	tmp = int2d(Th)( (w-we)^2 );
	
	return tmp;
} 

/* Per il calcolo dell'errore di || pi*y -y_k ||L2 viene sommata ad ogni passo temporale la norma L2
 * la funzione seguente sfrutta il vettore di soluzioni del problema di stato
 */
func real normL2state()
{
	real tmp=0., savet=0.;
	
	savet = 0.;
	t=dt;
	
	for(int i =0; i<nsol; i++)
	{
		tmp += dt*int2d(Th)( (statesol[i]-we)^2 );
		t += dt;
	}
	
	tmp = sqrt(tmp);
	
	t=savet;
	
	return tmp;
} 

/* Per il calcolo dell'errore di || yes -pi*y_k ||L2 viene implementato il metodo dei trapezi
*/
func real stateprojtrap()
{
	real tmp=0.;
	
	//Inizializzo correttamente le variabili di supporto ogni volta che chiamo la funzione
	t1=dt*3./2.;
	t2=dt/2.;
	
	tmp = (   int2d(Th)( ( 1.5*statesol[0] - 0.5*statesol[1] - 1.5*wesx + 0.5*wedx )^2 )
	       + int2d(Th)( ( (statesol[0]-wesx)^2 ) )
	       + (1./4.)*int2d(Th)( ( 5*statesol[0]-statesol[1]-5*wesx +wedx )^2 )
		    )*(dt/12.);
	
	for( int i=1; i< nsol-3; i++)
	{
		tmp += (   int2d(Th)( ( (statesol[i-1]-wesx)^2 ) )
					+ int2d(Th)( ( (statesol[i]-wedx)^2 ) )
					+ int2d(Th)( ( statesol[i]+statesol[i-1]-wesx -wedx )^2 ) 
					  )*(dt/6.);
		t1 += dt;
		t2 += dt;
	}
	
	tmp += (   int2d(Th)( ( 1.5*statesol[nsol-2] - 0.5*statesol[nsol-3] - 1.5*wedx + 0.5*wesx )^2 )
	  	    + int2d(Th)( ( (statesol[nsol-2]-wedx)^2 ) )
			+ (1./4.)*int2d(Th)( ( 5*statesol[nsol-2]-statesol[nsol-3]-5*wedx +wesx )^2 )
			  )*(dt/12.);
	
	tmp = sqrt(tmp);
	
	return tmp;
}

/* Per il calcolo dell'errore di || yes - y_k ||Linf
*/
func real normLinfstate()
{
	Yh diff;
	real[int] LinfSpazio(nsol);
	real norm, tsave=t;
	t=dt;
	
	for(int i=0; i<nsol; i++)
	{
		diff = statesol[i] -we;
		
		LinfSpazio[i] = diff[].linfty;
		
		t+=dt;
	}
	
	norm = LinfSpazio.linfty;

	t=tsave;
	
	return norm;
}

/* Per il calcolo dell'errore di || ues -u_k ||L2 viene implementato il metodo dei trapezi
 */
func real controltrap(real[int]& controlsol)
{
	real tmp=0., med=0.;
	
	for( int i=0; i< nsol-1; i++)
	{

		tmp += (   int2d(Th)( ( (controlsol[i]-ue[i])^2 ) )
				 + int2d(Th)( ( (controlsol[i+1]-ue[i+1])^2 ) )
					  )*(dt/2.);
		
	}
	
	tmp = sqrt(tmp);
	
	return tmp;
}

/* Calcolo della || ues - u_k ||L2 con il metodo di cavalieri simpson
 */
func real controlCS(real[int]& controlsol)
{
	real tmp=0., med=0.;
	
	for( int i=0; i< nsol-1; i++)
	{
		med = (Bpk[i] + Bpk[i+1])/2.;
		med = PUabScal(med);
		
		tmp += (   int2d(Th)( ( (controlsol[i]-ue[i])^2 ) )
				 + int2d(Th)( ( (controlsol[i+1]-ue[i+1])^2 ) )
				 + int2d(Th)( ( 4.*( uemed[i] - med )^2) )
					  )*(dt/6.);
		
	}
	
	tmp = sqrt(tmp);
	
	return tmp;
}

/* Per il calcolo dell'errore di || ues -u_k ||Linf
*/
func real normLinfcontrol()
{
	Yh diff;
	real[int] LinfSpazio(nsol);
	real norm, tsave=t;
	t=dt;
	
	for(int i=0; i<nsol; i++)
	{
		diff = statesol[i] -we;
		
		LinfSpazio[i] = diff[].linfty;
		
		t+=dt;
	}
	
	norm = LinfSpazio.linfty;

	t=tsave;
	
	return norm;
}