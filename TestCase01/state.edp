/*********************** Politecnico di Milano - ANEDP project ************************/
/* 														 					          *
 *  	authors Edoardo Arbib 							 					          *
 *				Claudia Bonomi 							 					          *
 *											   			 					          *
 *  	Descrizione: Per il problema di stato definiamo  					          *
 *						- spazi funzionali		         					          *
 *						- problema spaziale				 					          *
 *					    - funzione per la soluzione del problema temporale            * 
 *    					- norme dell'errore e analisi di convergenza                  *
 * 														 				 	 	 	  *
 * 		Dipendenze: main -> nsol + paramtri temporali + u(=soluzione controllo)  	  * 
 *						 -> alpha parametro del problema di controllo 				  *
 * 					soluzioniEsatte -> soluzione esatta di y e parametri t1 e t2 	  * 
 * 									   necessarie per il calcolo dell'errore     	  *
 * 					funzioni -> wa ed a1								 			  *
 * 														 				 	 	 	  *
 **************************************************************************************/

	
/****************** 00.PARAMETRI E FUNZIONI ******************/
// w0 soluzione all'istante iniziale
t=0.;
func w0 = -1.*(pi^2*wa)/(2+a1);

// wb funzione al bordo di dirchlet 
func wb = 0.;

/*la forzante del problema ha la seguente forma
 *	g0(t,x,y) = -pi^(4)*wa - PUad(-(exp(a1*pi^2*t)+exp(a1*pi^2*T))/(4.*alpha))
 * per calcolare il secondo termine è necessario usare le variabili di ausilio g0part e g0II
 * poichè freefem non ci permette di aglomerare le funzioni in un unica riga faremo dunque:
 * 		g0part= g0exp;
 *		g0II = PUabScal(g0part);
 */
func g0I = -pi^(4)*wa;
func g0exp = -(exp(a1*pi^2*t)+exp(a1*pi^2*T))/(4.*alpha);
real g0part, g0II;

func g0 = g0I - g0II;

/* Parametri per il calcolo dell'errore dello stato
 * errStateL2 = || pi*y -y_k ||L2
 *
 * errProjectStateL2 = || y -pi*y_k ||L2
 */
real errStateL2=0.;
real errProjectStateL2 = 0.; 
real errStateLinf = 0.; 

/****************** 01.SPAZI FUNZIONALI ******************/

fespace Yh( Th, P2 );

/* w soluzione del problema di stato al passo temporale corrente
 * wold suluzione del problema di stato al passo temporale precedente
 * wtest funzione test
 * g0old forzante al passo temporale precedente
 */
Yh w, wold, wtest, g0old;

//vettore della soluzioni w ad ogni passo temporale
Yh[int] statesol(nsol);

/* nel file funzioniErrore.edp le funzioni necessarie per il calcolo dell'errore del problema di stato
 * e di quello di controllo 
 */
include "funzioniErrore.edp";

/******************  02.PROBLEMA SPAZIALE ******************/
 
/* Lo schema di integrazione temporale implementato è una variante di Crank-Nicolson
 * in particolare viene effettuato:
 *  un passo di EI con passo temporale dimezzato
 *  nsol-2 passi di CN
 *  un passo di EA
 * Per questo motivo la matrice S rimane invariata dal primo al penultimo passo
 *  il parametro gamma verà settato a zero prima che la matrice S venga ricacolata 
 *  nel ultimo passo.
 */
real gamma=0.5;

/* uold e ui contengono il valore della soluzione di controllo al tempo t e t-dt
 * Al passo di EI solo la componente u(0) deve essere considerata
 * Per ogni passo i di CN le componenti u(i) ed u(i-1) devono essere considerati
 * Al passo di EA solo la componente u(nsol-1) deve essere considerata
 */
real uold=0., ui;

varf s(w,wtest) =   int2d(Th)( w*wtest/dt )
	        	  + int2d(Th)( gamma*( dx(w)*dx(wtest) + dy(w)*dy(wtest) ) )
				  + on(1,2,3,4, w=wb);

varf statetn(w,wtest) =   int2d(Th)( wold*wtest/dt )
				  		- int2d(Th)( 0.5*( dx(wold)*dx(wtest) + dy(wold)*dy(wtest) )*(t>dt) )
						+ int2d(Th)( 0.5*( (uold + g0old)*wtest )*(t>dt) ) 
						+ int2d(Th)( gamma*( (ui + g0)*wtest ) );
					  
matrix S; 
real[int] statebc(Yh.ndof);


/****** 03.FUNZIONE PER SOLUZIONE IN TEMPO ******/ 

func real statet()
{
	cout << "State " << endl;
	
	real[int] tmp(Yh.ndof);
	//real errL2=0.;
	
	//inizializzo le variabili iniziali ogni volta che chiamo la funzione
	wold=w0;
	t=dt;
	
	//Setto gamma a 0.5 ogni volta che chiamo la funzione
	gamma = 0.5;
	//Calcolo S e bc
	S=s(Yh,Yh,solver=UMFPACK);
	statebc=s(0,Yh);

	//devo fare (nsol-1) passi prima di ricalcolare la matrice S per l'ultimo passo di EA
	for( int i=0; i<nsol-1; i++ )
	{
		//setto le variabili ui ed uold asicurandomi di non andare ad accedere la posizione u[-1]
		if( i > 0 )
		{
			uold= u[i-1];
		}
		
		ui=u[i];
		
		//aggiorno g0II
		g0part= g0exp;
		g0II = PUabScal(g0part);
		
		tmp = statetn(0,Yh);
		tmp += statebc;
		
		//Risolvo
		w[] = S^-1*tmp;
		
		// salvo la mia soluzione al passo precedente
		statesol[i]=w;
		
		//aggiorno wold, il tempo e g0old
		wold=w;
		t += dt;
		g0old = g0;
		
	}
	
	// passo di EA
	gamma=0.;
	
	S=s(Yh,Yh);
	
	tmp = statetn(0,Yh);
	tmp += statebc;
	
	w[] = S^-1*tmp;
	
	statesol[nsol-1]=w;

	//Calcolo dell'errore
	errStateL2 = normL2state();

	errProjectStateL2 = stateprojtrap();

	errStateLinf = normLinfstate();
	
	//cout << "errore state L2  " << errStateL2 << endl;
	//cout << "errore project state L2  " << errProjectStateL2 << endl;
	//cout << "errore state Linf  " << errStateLinf << endl;
	
	return 0;
}



















